let readdirSync,statSync,join,slash,URL,createTask,transitionTo,uploadFiles,failed,initial,preparing,skipped,starting,success,uploading;_ab9‍.x([["uploadStorybook",()=>uploadStorybook],["default",()=>_ab9‍.o]]);_ab9‍.w("fs",[["readdirSync",["readdirSync"],function(v){readdirSync=v}],["statSync",["statSync"],function(v){statSync=v}]]);_ab9‍.w("path",[["join",["join"],function(v){join=v}]]);_ab9‍.w("slash",[["default",["slash"],function(v){slash=v}]]);_ab9‍.w("url",[["URL",["URL"],function(v){URL=v}]]);_ab9‍.w("../lib/tasks",[["createTask",["createTask"],function(v){createTask=v}],["transitionTo",["transitionTo"],function(v){transitionTo=v}]]);_ab9‍.w("../lib/uploadFiles",[["default",["uploadFiles"],function(v){uploadFiles=v}]]);_ab9‍.w("../ui/tasks/upload",[["failed",["failed"],function(v){failed=v}],["initial",["initial"],function(v){initial=v}],["preparing",["preparing"],function(v){preparing=v}],["skipped",["skipped"],function(v){skipped=v}],["starting",["starting"],function(v){starting=v}],["success",["success"],function(v){success=v}],["uploading",["uploading"],function(v){uploading=v}]]);/* eslint-disable no-param-reassign */

















const TesterGetUploadUrlsMutation = `
  mutation TesterGetUploadUrlsMutation($paths: [String!]!) {
    getUploadUrls(paths: $paths) {
      domain
      urls {
        path
        url
        contentType
      }
    }
  }
`;

// Get all paths in rootDir, starting at dirname.
// We don't want the paths to include rootDir -- so if rootDir = storybook-static,
// paths will be like iframe.html rather than storybook-static/iframe.html
function getPathsInDir(rootDir, dirname = '.') {
  return readdirSync(join(rootDir, dirname))
    .map(p => join(dirname, p))
    .map(pathname => {
      const stats = statSync(join(rootDir, pathname));
      if (stats.isDirectory()) {
        return getPathsInDir(rootDir, pathname);
      }
      return [{ pathname, contentLength: stats.size }];
    })
    .reduce((a, b) => [...a, ...b], []); // flatten
}

       const uploadStorybook = async (ctx, task) => {
  const { client, sourceDir } = ctx;

  const pathAndLengths = getPathsInDir(sourceDir).map(o => ({ ...o, knownAs: slash(o.pathname) }));
  const paths = pathAndLengths.map(({ knownAs }) => knownAs);
  const total = pathAndLengths.map(({ contentLength }) => contentLength).reduce((a, b) => a + b, 0);

  task.output = preparing(ctx).output;

  const { getUploadUrls } = await client.runQuery(TesterGetUploadUrlsMutation, { paths });
  const { domain, urls } = getUploadUrls;
  const files = urls.map(({ path, url, contentType }) => ({
    path: join(sourceDir, path),
    url,
    contentType,
    contentLength: pathAndLengths.find(({ knownAs }) => knownAs === path).contentLength,
  }));

  task.output = starting(ctx).output;

  try {
    await uploadFiles(ctx, files, progress => {
      if (ctx.options.interactive) {
        const percentage = Math.round((progress / total) * 100);
        task.output = uploading({ percentage }).output;
      }
    });
  } catch (e) {
    if (files.find(({ path }) => path === e.message)) {
      throw new Error(failed({ path: e.message }).output);
    }
    throw e;
  }

  ctx.uploadedBytes = total;
  ctx.isolatorUrl = new URL('/iframe.html', domain).toString();
};

_ab9‍.d(createTask({
  title: initial.title,
  skip: ctx => {
    if (ctx.skip) return true;
    if (ctx.options.storybookUrl) return skipped(ctx).output;
    return false;
  },
  steps: [transitionTo(preparing), uploadStorybook, transitionTo(success, true)],
}));
